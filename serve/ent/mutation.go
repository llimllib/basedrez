// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/llimllib/basedrez/ent/game"
	"github.com/llimllib/basedrez/ent/predicate"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeGame = "Game"
)

// GameMutation represents an operation that mutates the Game nodes in the graph.
type GameMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	whitePlayerId         *string
	whitePlayerName       *string
	whitePlayerRatingDiff *string
	blackPlayerId         *string
	blackPlayerName       *string
	blackPlayerRatingDiff *string
	winner                *string
	moves                 *string
	clockInitial          *string
	clockIncrement        *string
	clockTotal            *string
	pgn                   *string
	rated                 *string
	variant               *string
	speed                 *string
	perf                  *string
	createdAt             *string
	lastMoveAt            *string
	status                *string
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*Game, error)
	predicates            []predicate.Game
}

var _ ent.Mutation = (*GameMutation)(nil)

// gameOption allows management of the mutation configuration using functional options.
type gameOption func(*GameMutation)

// newGameMutation creates new mutation for the Game entity.
func newGameMutation(c config, op Op, opts ...gameOption) *GameMutation {
	m := &GameMutation{
		config:        c,
		op:            op,
		typ:           TypeGame,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGameID sets the ID field of the mutation.
func withGameID(id string) gameOption {
	return func(m *GameMutation) {
		var (
			err   error
			once  sync.Once
			value *Game
		)
		m.oldValue = func(ctx context.Context) (*Game, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Game.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGame sets the old Game of the mutation.
func withGame(node *Game) gameOption {
	return func(m *GameMutation) {
		m.oldValue = func(context.Context) (*Game, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Game entities.
func (m *GameMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GameMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GameMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Game.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWhitePlayerId sets the "whitePlayerId" field.
func (m *GameMutation) SetWhitePlayerId(s string) {
	m.whitePlayerId = &s
}

// WhitePlayerId returns the value of the "whitePlayerId" field in the mutation.
func (m *GameMutation) WhitePlayerId() (r string, exists bool) {
	v := m.whitePlayerId
	if v == nil {
		return
	}
	return *v, true
}

// OldWhitePlayerId returns the old "whitePlayerId" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldWhitePlayerId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWhitePlayerId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWhitePlayerId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWhitePlayerId: %w", err)
	}
	return oldValue.WhitePlayerId, nil
}

// ResetWhitePlayerId resets all changes to the "whitePlayerId" field.
func (m *GameMutation) ResetWhitePlayerId() {
	m.whitePlayerId = nil
}

// SetWhitePlayerName sets the "whitePlayerName" field.
func (m *GameMutation) SetWhitePlayerName(s string) {
	m.whitePlayerName = &s
}

// WhitePlayerName returns the value of the "whitePlayerName" field in the mutation.
func (m *GameMutation) WhitePlayerName() (r string, exists bool) {
	v := m.whitePlayerName
	if v == nil {
		return
	}
	return *v, true
}

// OldWhitePlayerName returns the old "whitePlayerName" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldWhitePlayerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWhitePlayerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWhitePlayerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWhitePlayerName: %w", err)
	}
	return oldValue.WhitePlayerName, nil
}

// ResetWhitePlayerName resets all changes to the "whitePlayerName" field.
func (m *GameMutation) ResetWhitePlayerName() {
	m.whitePlayerName = nil
}

// SetWhitePlayerRatingDiff sets the "whitePlayerRatingDiff" field.
func (m *GameMutation) SetWhitePlayerRatingDiff(s string) {
	m.whitePlayerRatingDiff = &s
}

// WhitePlayerRatingDiff returns the value of the "whitePlayerRatingDiff" field in the mutation.
func (m *GameMutation) WhitePlayerRatingDiff() (r string, exists bool) {
	v := m.whitePlayerRatingDiff
	if v == nil {
		return
	}
	return *v, true
}

// OldWhitePlayerRatingDiff returns the old "whitePlayerRatingDiff" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldWhitePlayerRatingDiff(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWhitePlayerRatingDiff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWhitePlayerRatingDiff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWhitePlayerRatingDiff: %w", err)
	}
	return oldValue.WhitePlayerRatingDiff, nil
}

// ResetWhitePlayerRatingDiff resets all changes to the "whitePlayerRatingDiff" field.
func (m *GameMutation) ResetWhitePlayerRatingDiff() {
	m.whitePlayerRatingDiff = nil
}

// SetBlackPlayerId sets the "blackPlayerId" field.
func (m *GameMutation) SetBlackPlayerId(s string) {
	m.blackPlayerId = &s
}

// BlackPlayerId returns the value of the "blackPlayerId" field in the mutation.
func (m *GameMutation) BlackPlayerId() (r string, exists bool) {
	v := m.blackPlayerId
	if v == nil {
		return
	}
	return *v, true
}

// OldBlackPlayerId returns the old "blackPlayerId" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldBlackPlayerId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlackPlayerId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlackPlayerId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlackPlayerId: %w", err)
	}
	return oldValue.BlackPlayerId, nil
}

// ResetBlackPlayerId resets all changes to the "blackPlayerId" field.
func (m *GameMutation) ResetBlackPlayerId() {
	m.blackPlayerId = nil
}

// SetBlackPlayerName sets the "blackPlayerName" field.
func (m *GameMutation) SetBlackPlayerName(s string) {
	m.blackPlayerName = &s
}

// BlackPlayerName returns the value of the "blackPlayerName" field in the mutation.
func (m *GameMutation) BlackPlayerName() (r string, exists bool) {
	v := m.blackPlayerName
	if v == nil {
		return
	}
	return *v, true
}

// OldBlackPlayerName returns the old "blackPlayerName" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldBlackPlayerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlackPlayerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlackPlayerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlackPlayerName: %w", err)
	}
	return oldValue.BlackPlayerName, nil
}

// ResetBlackPlayerName resets all changes to the "blackPlayerName" field.
func (m *GameMutation) ResetBlackPlayerName() {
	m.blackPlayerName = nil
}

// SetBlackPlayerRatingDiff sets the "blackPlayerRatingDiff" field.
func (m *GameMutation) SetBlackPlayerRatingDiff(s string) {
	m.blackPlayerRatingDiff = &s
}

// BlackPlayerRatingDiff returns the value of the "blackPlayerRatingDiff" field in the mutation.
func (m *GameMutation) BlackPlayerRatingDiff() (r string, exists bool) {
	v := m.blackPlayerRatingDiff
	if v == nil {
		return
	}
	return *v, true
}

// OldBlackPlayerRatingDiff returns the old "blackPlayerRatingDiff" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldBlackPlayerRatingDiff(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlackPlayerRatingDiff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlackPlayerRatingDiff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlackPlayerRatingDiff: %w", err)
	}
	return oldValue.BlackPlayerRatingDiff, nil
}

// ResetBlackPlayerRatingDiff resets all changes to the "blackPlayerRatingDiff" field.
func (m *GameMutation) ResetBlackPlayerRatingDiff() {
	m.blackPlayerRatingDiff = nil
}

// SetWinner sets the "winner" field.
func (m *GameMutation) SetWinner(s string) {
	m.winner = &s
}

// Winner returns the value of the "winner" field in the mutation.
func (m *GameMutation) Winner() (r string, exists bool) {
	v := m.winner
	if v == nil {
		return
	}
	return *v, true
}

// OldWinner returns the old "winner" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldWinner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWinner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWinner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWinner: %w", err)
	}
	return oldValue.Winner, nil
}

// ResetWinner resets all changes to the "winner" field.
func (m *GameMutation) ResetWinner() {
	m.winner = nil
}

// SetMoves sets the "moves" field.
func (m *GameMutation) SetMoves(s string) {
	m.moves = &s
}

// Moves returns the value of the "moves" field in the mutation.
func (m *GameMutation) Moves() (r string, exists bool) {
	v := m.moves
	if v == nil {
		return
	}
	return *v, true
}

// OldMoves returns the old "moves" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldMoves(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMoves is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMoves requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMoves: %w", err)
	}
	return oldValue.Moves, nil
}

// ResetMoves resets all changes to the "moves" field.
func (m *GameMutation) ResetMoves() {
	m.moves = nil
}

// SetClockInitial sets the "clockInitial" field.
func (m *GameMutation) SetClockInitial(s string) {
	m.clockInitial = &s
}

// ClockInitial returns the value of the "clockInitial" field in the mutation.
func (m *GameMutation) ClockInitial() (r string, exists bool) {
	v := m.clockInitial
	if v == nil {
		return
	}
	return *v, true
}

// OldClockInitial returns the old "clockInitial" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldClockInitial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClockInitial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClockInitial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClockInitial: %w", err)
	}
	return oldValue.ClockInitial, nil
}

// ResetClockInitial resets all changes to the "clockInitial" field.
func (m *GameMutation) ResetClockInitial() {
	m.clockInitial = nil
}

// SetClockIncrement sets the "clockIncrement" field.
func (m *GameMutation) SetClockIncrement(s string) {
	m.clockIncrement = &s
}

// ClockIncrement returns the value of the "clockIncrement" field in the mutation.
func (m *GameMutation) ClockIncrement() (r string, exists bool) {
	v := m.clockIncrement
	if v == nil {
		return
	}
	return *v, true
}

// OldClockIncrement returns the old "clockIncrement" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldClockIncrement(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClockIncrement is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClockIncrement requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClockIncrement: %w", err)
	}
	return oldValue.ClockIncrement, nil
}

// ResetClockIncrement resets all changes to the "clockIncrement" field.
func (m *GameMutation) ResetClockIncrement() {
	m.clockIncrement = nil
}

// SetClockTotal sets the "clockTotal" field.
func (m *GameMutation) SetClockTotal(s string) {
	m.clockTotal = &s
}

// ClockTotal returns the value of the "clockTotal" field in the mutation.
func (m *GameMutation) ClockTotal() (r string, exists bool) {
	v := m.clockTotal
	if v == nil {
		return
	}
	return *v, true
}

// OldClockTotal returns the old "clockTotal" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldClockTotal(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClockTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClockTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClockTotal: %w", err)
	}
	return oldValue.ClockTotal, nil
}

// ResetClockTotal resets all changes to the "clockTotal" field.
func (m *GameMutation) ResetClockTotal() {
	m.clockTotal = nil
}

// SetPgn sets the "pgn" field.
func (m *GameMutation) SetPgn(s string) {
	m.pgn = &s
}

// Pgn returns the value of the "pgn" field in the mutation.
func (m *GameMutation) Pgn() (r string, exists bool) {
	v := m.pgn
	if v == nil {
		return
	}
	return *v, true
}

// OldPgn returns the old "pgn" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldPgn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPgn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPgn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPgn: %w", err)
	}
	return oldValue.Pgn, nil
}

// ResetPgn resets all changes to the "pgn" field.
func (m *GameMutation) ResetPgn() {
	m.pgn = nil
}

// SetRated sets the "rated" field.
func (m *GameMutation) SetRated(s string) {
	m.rated = &s
}

// Rated returns the value of the "rated" field in the mutation.
func (m *GameMutation) Rated() (r string, exists bool) {
	v := m.rated
	if v == nil {
		return
	}
	return *v, true
}

// OldRated returns the old "rated" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldRated(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRated: %w", err)
	}
	return oldValue.Rated, nil
}

// ResetRated resets all changes to the "rated" field.
func (m *GameMutation) ResetRated() {
	m.rated = nil
}

// SetVariant sets the "variant" field.
func (m *GameMutation) SetVariant(s string) {
	m.variant = &s
}

// Variant returns the value of the "variant" field in the mutation.
func (m *GameMutation) Variant() (r string, exists bool) {
	v := m.variant
	if v == nil {
		return
	}
	return *v, true
}

// OldVariant returns the old "variant" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldVariant(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariant is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariant: %w", err)
	}
	return oldValue.Variant, nil
}

// ResetVariant resets all changes to the "variant" field.
func (m *GameMutation) ResetVariant() {
	m.variant = nil
}

// SetSpeed sets the "speed" field.
func (m *GameMutation) SetSpeed(s string) {
	m.speed = &s
}

// Speed returns the value of the "speed" field in the mutation.
func (m *GameMutation) Speed() (r string, exists bool) {
	v := m.speed
	if v == nil {
		return
	}
	return *v, true
}

// OldSpeed returns the old "speed" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldSpeed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpeed: %w", err)
	}
	return oldValue.Speed, nil
}

// ResetSpeed resets all changes to the "speed" field.
func (m *GameMutation) ResetSpeed() {
	m.speed = nil
}

// SetPerf sets the "perf" field.
func (m *GameMutation) SetPerf(s string) {
	m.perf = &s
}

// Perf returns the value of the "perf" field in the mutation.
func (m *GameMutation) Perf() (r string, exists bool) {
	v := m.perf
	if v == nil {
		return
	}
	return *v, true
}

// OldPerf returns the old "perf" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldPerf(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPerf is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPerf requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPerf: %w", err)
	}
	return oldValue.Perf, nil
}

// ResetPerf resets all changes to the "perf" field.
func (m *GameMutation) ResetPerf() {
	m.perf = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *GameMutation) SetCreatedAt(s string) {
	m.createdAt = &s
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *GameMutation) CreatedAt() (r string, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldCreatedAt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *GameMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetLastMoveAt sets the "lastMoveAt" field.
func (m *GameMutation) SetLastMoveAt(s string) {
	m.lastMoveAt = &s
}

// LastMoveAt returns the value of the "lastMoveAt" field in the mutation.
func (m *GameMutation) LastMoveAt() (r string, exists bool) {
	v := m.lastMoveAt
	if v == nil {
		return
	}
	return *v, true
}

// OldLastMoveAt returns the old "lastMoveAt" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldLastMoveAt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastMoveAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastMoveAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastMoveAt: %w", err)
	}
	return oldValue.LastMoveAt, nil
}

// ResetLastMoveAt resets all changes to the "lastMoveAt" field.
func (m *GameMutation) ResetLastMoveAt() {
	m.lastMoveAt = nil
}

// SetStatus sets the "status" field.
func (m *GameMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *GameMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *GameMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the GameMutation builder.
func (m *GameMutation) Where(ps ...predicate.Game) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GameMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Game).
func (m *GameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GameMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.whitePlayerId != nil {
		fields = append(fields, game.FieldWhitePlayerId)
	}
	if m.whitePlayerName != nil {
		fields = append(fields, game.FieldWhitePlayerName)
	}
	if m.whitePlayerRatingDiff != nil {
		fields = append(fields, game.FieldWhitePlayerRatingDiff)
	}
	if m.blackPlayerId != nil {
		fields = append(fields, game.FieldBlackPlayerId)
	}
	if m.blackPlayerName != nil {
		fields = append(fields, game.FieldBlackPlayerName)
	}
	if m.blackPlayerRatingDiff != nil {
		fields = append(fields, game.FieldBlackPlayerRatingDiff)
	}
	if m.winner != nil {
		fields = append(fields, game.FieldWinner)
	}
	if m.moves != nil {
		fields = append(fields, game.FieldMoves)
	}
	if m.clockInitial != nil {
		fields = append(fields, game.FieldClockInitial)
	}
	if m.clockIncrement != nil {
		fields = append(fields, game.FieldClockIncrement)
	}
	if m.clockTotal != nil {
		fields = append(fields, game.FieldClockTotal)
	}
	if m.pgn != nil {
		fields = append(fields, game.FieldPgn)
	}
	if m.rated != nil {
		fields = append(fields, game.FieldRated)
	}
	if m.variant != nil {
		fields = append(fields, game.FieldVariant)
	}
	if m.speed != nil {
		fields = append(fields, game.FieldSpeed)
	}
	if m.perf != nil {
		fields = append(fields, game.FieldPerf)
	}
	if m.createdAt != nil {
		fields = append(fields, game.FieldCreatedAt)
	}
	if m.lastMoveAt != nil {
		fields = append(fields, game.FieldLastMoveAt)
	}
	if m.status != nil {
		fields = append(fields, game.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case game.FieldWhitePlayerId:
		return m.WhitePlayerId()
	case game.FieldWhitePlayerName:
		return m.WhitePlayerName()
	case game.FieldWhitePlayerRatingDiff:
		return m.WhitePlayerRatingDiff()
	case game.FieldBlackPlayerId:
		return m.BlackPlayerId()
	case game.FieldBlackPlayerName:
		return m.BlackPlayerName()
	case game.FieldBlackPlayerRatingDiff:
		return m.BlackPlayerRatingDiff()
	case game.FieldWinner:
		return m.Winner()
	case game.FieldMoves:
		return m.Moves()
	case game.FieldClockInitial:
		return m.ClockInitial()
	case game.FieldClockIncrement:
		return m.ClockIncrement()
	case game.FieldClockTotal:
		return m.ClockTotal()
	case game.FieldPgn:
		return m.Pgn()
	case game.FieldRated:
		return m.Rated()
	case game.FieldVariant:
		return m.Variant()
	case game.FieldSpeed:
		return m.Speed()
	case game.FieldPerf:
		return m.Perf()
	case game.FieldCreatedAt:
		return m.CreatedAt()
	case game.FieldLastMoveAt:
		return m.LastMoveAt()
	case game.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case game.FieldWhitePlayerId:
		return m.OldWhitePlayerId(ctx)
	case game.FieldWhitePlayerName:
		return m.OldWhitePlayerName(ctx)
	case game.FieldWhitePlayerRatingDiff:
		return m.OldWhitePlayerRatingDiff(ctx)
	case game.FieldBlackPlayerId:
		return m.OldBlackPlayerId(ctx)
	case game.FieldBlackPlayerName:
		return m.OldBlackPlayerName(ctx)
	case game.FieldBlackPlayerRatingDiff:
		return m.OldBlackPlayerRatingDiff(ctx)
	case game.FieldWinner:
		return m.OldWinner(ctx)
	case game.FieldMoves:
		return m.OldMoves(ctx)
	case game.FieldClockInitial:
		return m.OldClockInitial(ctx)
	case game.FieldClockIncrement:
		return m.OldClockIncrement(ctx)
	case game.FieldClockTotal:
		return m.OldClockTotal(ctx)
	case game.FieldPgn:
		return m.OldPgn(ctx)
	case game.FieldRated:
		return m.OldRated(ctx)
	case game.FieldVariant:
		return m.OldVariant(ctx)
	case game.FieldSpeed:
		return m.OldSpeed(ctx)
	case game.FieldPerf:
		return m.OldPerf(ctx)
	case game.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case game.FieldLastMoveAt:
		return m.OldLastMoveAt(ctx)
	case game.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Game field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case game.FieldWhitePlayerId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWhitePlayerId(v)
		return nil
	case game.FieldWhitePlayerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWhitePlayerName(v)
		return nil
	case game.FieldWhitePlayerRatingDiff:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWhitePlayerRatingDiff(v)
		return nil
	case game.FieldBlackPlayerId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlackPlayerId(v)
		return nil
	case game.FieldBlackPlayerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlackPlayerName(v)
		return nil
	case game.FieldBlackPlayerRatingDiff:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlackPlayerRatingDiff(v)
		return nil
	case game.FieldWinner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWinner(v)
		return nil
	case game.FieldMoves:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMoves(v)
		return nil
	case game.FieldClockInitial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClockInitial(v)
		return nil
	case game.FieldClockIncrement:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClockIncrement(v)
		return nil
	case game.FieldClockTotal:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClockTotal(v)
		return nil
	case game.FieldPgn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPgn(v)
		return nil
	case game.FieldRated:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRated(v)
		return nil
	case game.FieldVariant:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariant(v)
		return nil
	case game.FieldSpeed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpeed(v)
		return nil
	case game.FieldPerf:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPerf(v)
		return nil
	case game.FieldCreatedAt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case game.FieldLastMoveAt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastMoveAt(v)
		return nil
	case game.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Game field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GameMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GameMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Game numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GameMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GameMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Game nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GameMutation) ResetField(name string) error {
	switch name {
	case game.FieldWhitePlayerId:
		m.ResetWhitePlayerId()
		return nil
	case game.FieldWhitePlayerName:
		m.ResetWhitePlayerName()
		return nil
	case game.FieldWhitePlayerRatingDiff:
		m.ResetWhitePlayerRatingDiff()
		return nil
	case game.FieldBlackPlayerId:
		m.ResetBlackPlayerId()
		return nil
	case game.FieldBlackPlayerName:
		m.ResetBlackPlayerName()
		return nil
	case game.FieldBlackPlayerRatingDiff:
		m.ResetBlackPlayerRatingDiff()
		return nil
	case game.FieldWinner:
		m.ResetWinner()
		return nil
	case game.FieldMoves:
		m.ResetMoves()
		return nil
	case game.FieldClockInitial:
		m.ResetClockInitial()
		return nil
	case game.FieldClockIncrement:
		m.ResetClockIncrement()
		return nil
	case game.FieldClockTotal:
		m.ResetClockTotal()
		return nil
	case game.FieldPgn:
		m.ResetPgn()
		return nil
	case game.FieldRated:
		m.ResetRated()
		return nil
	case game.FieldVariant:
		m.ResetVariant()
		return nil
	case game.FieldSpeed:
		m.ResetSpeed()
		return nil
	case game.FieldPerf:
		m.ResetPerf()
		return nil
	case game.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case game.FieldLastMoveAt:
		m.ResetLastMoveAt()
		return nil
	case game.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Game field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GameMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GameMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GameMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GameMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GameMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Game unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GameMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Game edge %s", name)
}
